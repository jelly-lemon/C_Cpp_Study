/*
请实现有重复数字的升序数组的二分查找
给定一个 元素有序的（升序）整型数组 nums 和一个目标值 target  ，
写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1

[1,2,3]:2 --> 1
[1,2,3,4]:2 -->1
[1,2,3,4,5]:6 --> -1
[1,2,3,4,5,6]:0 --> -1
[1,2,2,3,4]:2 --> 1
[0,1,2,2,4]:2 --> 2
 */

int search(vector<int>& nums, int target) {
    // write code here
    int i, j;
    int pos = -1;

    i = 0, j = nums.size() - 1;    // i，j 分别表示当前首查找位置、当前尾查找位置
    // 查找结束条件为 i > j
    while (i <= j ) {
        if (target == nums[(i+j)/2]) {
            pos = (i+j)/2;
            break;
            // 当目标值小于数组中间元素，则说明在左边
        } else if (target < nums[(i+j)/2]) {
            // 【易错点】新尾查找位置应该应该位于中间点左边一位，因为中间点已经比对过了，不是目标值。
            j = (i+j)/2 - 1;
        } else {
            i = (i+j)/2 + 1;
        }
    }

    // 不确定前面还有没有重复的，再往前看一下
    int t = pos -1;
    // 【易错点】要先判断一下 t 是否越界，因为有可能查找到的元素是第一个元素，前面没有元素了
    if (t >= 0) {
        while (nums[t] == target && t >= 0) {
            pos = t;
            t--;
        }
    }


    return pos;
}