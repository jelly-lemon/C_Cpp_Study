/**
 *
 *
 *

 题目：
 1208. 尽可能使字符串相等

 给你两个长度相同的字符串，s 和 t。
将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），
 也就是两个字符的 ASCII 码值的差的绝对值。
用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，
 这也意味着字符串的转化可能是不完全的。
如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。
如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。

 分析题目：
 已知条件：长度相同；
 限制：只能是对应位置的字符进行变化
 题目目的：在有限开销下，得到的最大收益
 有没有可能预算为0，返回最大长度？可以的，两个字符串相等的情况下

 【思路1：】
 遍历法。窗口大小从最大到最小（也就是s.length ~ 1），然后滑动窗口进行比较。
 伪代码：

 for (window_size = s.length; window_size > 0; windows_size - 1) {
    start = 0, end = window_size - 1;
    while (end + 1 <= s.length) {
        cur_cost = 0;   // 当前花费
        // 从窗口开始到结束
        for (i = start; i <= end; i++) {
            cur_cost = |s[i] - t[i]|
            if (cur_cost >= all_cost) {
                break;
            }
        }
        if (i == end) {
            // 找到最大长度，即此时窗口的大小
            return window;
        }

        start++, end++;
    }
 }

 【测试用例】
 - 两个完全相同的字符串，cost = 0 （最大长度应该为字符串的长度）
 - 两个差距很大的字符串（不可能变过去的那种）, cost = 0 （最大长度为 0）



 不知道这个算法对应什么实际问题？

 */
#include <stdio.h>


int main() {



    return 0;
}